# Sudoku

重排九宫问题的解决，采用两种方式：
1. 广度优先搜索
2. 启发式搜索

## 问题描述

重排九宫问题又称为八数码问题。在3×3的方格棋盘上放置分别标有数字1,2,3,4,5,6,7,8的8张牌,初始状态为S0，目标状态为Sg，其从左到右、从上到下顺序依次为1,2,3,8,0,4,7,6,5（0代表空格）。例如，图左所示是初始状态，图右所示是目标状态。

![image-20220207193008859](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220207193008859.png)

可使用的算符有空格左移、空格上移、空格右移和空格下移，即他们只允许把位于空格左、上、右、下边的牌移入空格。要求设计一个广度优先算法和一个启发式搜索算法寻找从初始状态到目标状态的路径，并对不同算法的性能进行比较分析。

 

## 算法描述

### **1.** **问题分析**

根据问题描述，我们可以看出这是一个状态空间的搜索问题，解决问题的过程就是一个寻找目标状态的搜索过程。通过运用搜索技术解决此问题的基本思想是，首先把问题的初始状态（即初始结点）作为当前状态，适当的对其进行运算操作，生成一组子状态（或后继状态、后继结点、子结点），然后检查目标状态是否在其中出观。若出现，则搜索成功，找到了问题的解；若不出现，则按某种搜索策略从已生成的状态中再选一个状态作为当前状态，重复上述过程，直到目标状态出现或者不再有可供运算操作的状态时为止。

对于本问题，搜索方法可以有很多，如广度优先搜索、深度优先搜索、代价树搜索、启发式搜索等，但他们最终都可以归为两大类——盲目搜索和启发式搜索。

盲目搜索是按照预定的控制策略进行搜索，在搜索的过程中获得的中间信息不被用来改进控制策略。这种搜索方式不考虑问题本身的特性，仅仅是教条地按照预定路线前进,具有盲目性，效率也不高，不适于复杂问题的求解。

启发式搜索在搜索中加入了与问题有关的启发式信息，用以指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。启发式搜索一般优于盲目搜索。但是启发信息的抽取往往具有一定的难度。

 

### **2.** **问题类的设计**

对于这类状态问题，因为会产生多个状态，因此可以设计一个类来表示九宫格的每个状态，因此，我设计了一个类Sudoku，类的成员变量如下：

```c++
  **vector**<**vector**<int>> myVec; //九宫格状态

  **suduko*** pre;  //结点的上一个状态结点

  int direct;  //上一个状态到当前状态的方向

  int depth;   //深度

  int value;   //估价

  int diff;   //与目标状态格局不相同的牌数
```

  这些成员变量当中，value和diff是启发式函数中需要使用的，在广度优先搜索中无需使用。  Sudoku类的成员函数如下：

```c++
  suduko(vector<vector<int>> v);

  void reset();
```

 

  可以看到成员函数很简单，一个是自定义的构造函数，一个是reset函数用来重新计算九宫格的启发式信息。构造函数使用默认的即可。

 

### **3.** **广度优先搜索算法的设计**

广度优先搜索的基本思想是：从初始结点S0开始，逐层地对结点进行扩展并考察它是否为目标结点，在第n层的结点没有全部扩展并考察完之前，不对第n+1层的结点进行扩展。OPEN表中的结点总是按照进入的先后顺序排列，先进入的结点排在前面，后进入的排在后面。在我的程序中，OPEN表是用C++的队列queue实现的。算法的步骤如下：

  Step1：输入九宫格的初始状态S0，把S0加入到队列中；

  Step2：当队列为空时，则问题无解，退出；

  Step3：把队列的第一个结点取出，用cur标记，准备进行考察；

  Step4：考察结点cur的九宫格状态是否为目标状态，如果是，则说明求出了问题的解，退出；

  Step5：如果结点cur不能扩展，则转向Step2；

  Step6：堆结点cur进行扩展，将其九宫格的空格进行向左、上、右、下四个方向移动，如果可以移动，则产生一个新的子节点，并对该结点的每个成员变量进行初始化，将pre指针指向cur。 然后把结点放入队列当中。然后转向Step2；

  Step7：利用pre指针，输出求解出的最佳路径。

 

  以开头的题目为例，输入初始状态为[2,8,3,1,0,4,7,6,5]，其广度优先搜索过程应该如下图所示，最优搜索路径用红色剪头标出：

![image-20220207193115682](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220207193115682.png)

### **4.** **启发式搜索算法的设计**

启发式搜索在搜索中加入了与问题有关的启发式信息，用以指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。

在本题中，设估价函数为

$$

f\left( x \right) =d\left( x \right) +h\left( x \right) 
$$
其中，d(x)表示节点x的深度; h(x)表示节点x的格局与目标节点格局不相同的牌数。

因此，启发式搜索算法的步骤如下：

  Step1：输入九宫格的初始状态S0，把S0加入到队列中；

  Step2：当队列为空时，则问题无解，退出；

  Step3：把队列的第一个结点取出，用cur标记，准备进行考察；

  Step4：考察结点cur的九宫格状态是否为目标状态，如果是，则说明求出了问题的解，退出；

  Step5：如果结点cur不能扩展，则转向Step2；

  Step6：堆结点cur进行扩展，将其九宫格的空格进行向左、上、右、下四个方向移动，如果可以移动，则产生一个新的子节点，并对该结点的每个成员变量进行初始化，根据估价函数f(x)计算每个子节点的估价值，将pre指针指向cur。把产生的结点放入队列当中，然后对队列中的全部结点按照估价进行从小到大排序。然后转向Step2；

  Step7：利用pre指针，输出求解出的最佳路径。

 

以开头的题目为例，输入初始状态为[2,8,3,1,0,4,7,6,5]，其广度优先搜索树应该如下图所示，最优搜索路径用红色剪头标出。图中节点旁的数字为该节点的估价值。

![image-20220207192806495](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20220207192806495.png)

## 实验结果分析

根据输出可以看到，对于这个输入，广度优先搜索产生了26种状态才找到目标状态，而启发式搜索只产生了12中状态便找到了目标状态。同时，他们找到路径是相同的，而且都是最优路径。

  另外，从这个例子可以看出启发式搜索的效率要高于广度优先搜索，但还不能确定这是否是个例，因此后面后采用更多的例子进行实验。

## 不同算法的性能分析

  为了使结论和性能分析更具有普适性，我选取了更多的例子进行检验，检验的结果如下：

| **初始状态序列**    | **广度优先搜索次数** | **启发式搜索次数** |
| ------------------- | -------------------- | ------------------ |
| [2,8,3,1,0,4,7,6,5] | 26                   | 12                 |
| [2,8,3,1,6,4,7,0,5] | 46                   | 14                 |
| [8,0,1,2,4,3,7,6,5] | 127                  | 31                 |
| [2,1,6,4,0,8,7,5,3] | 64352                | 5022               |

  

根据上表基本可以确定，启发式搜索比广度优先搜索这种盲目性搜索算法的效率要高。

## 参考文献

[1]董改芳,许道云.游戏中寻找路径的改进算法[J].计算机工程与应用,2009,45(23):38-39+81.

[2]毕智超.基于重排九宫问题的算法设计与实现[J].技术与市场,2017,24(09):53-54.

[3]詹志辉,胡晓敏,张军.通过八数码问题比较搜索算法的性能[J].计算机工程与设计,2007(11):2505-2508.
